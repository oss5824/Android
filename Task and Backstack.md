# Tasks and Back Stack
+ Task는 사용자에 의해 실행된 액티비티들의 모음
+ 액티비티들은 생성되면서 백스택이라 불리는 스택에 쌓이게 됨
+ 디바이스의 홈화면은 거의 모든 태스크들의 시작점으로 사용자가 앱 런처에서 앱 아이콘을 터치하거나 홈 화면의 바로가기 아이콘을 터치하면 앱의 태스크가 foreground로 나오게 됨(앱을 최근에 실행한적이 없어 태스크가 없다면 새 태스크가 생성되어 앱의 메인 액티비티가 실행되고 태스크의 root가 됨)
+ 현재 액티비티가 다른 액티비티를 실행하면 새 액티비티가 스택의 top에 들어가 포커스를 획득하고 이전 액티비티는 여전히 스택에 들어가 있기는 하지만 stopped상태가 됨(액티비티가 stop되더라도 시스템은 액티비티의 UI 현재상태를 보존)  
+ 사용자가 뒤로가기 버튼을 눌렀을 때 현재의 액티비티를 스택에서 꺼내고(액티비티 종료), 이전 액티비티를 resume상태로 만듦(정지되기 이전의 UI복구)
+ 스택에 있는 액티비티의 배열은 절대 바뀌지 않고 오직 push와 pop동작만 있을 뿐임
+ 태스크의 모든 액티비티가 제거되면 해당 태스크도 없어짐
+ Task는 사용자가 다른 태스크를 시작하거나 홈버튼을 눌러서 홈화면으로 전환될 때 background로 이동하고 태스크의 모든 액티비티들은 stopped상태가 되지만 태스크의 백스택은 액티비티들을 잘 유지하기 때문에 자리를 내주고 포커스만 잃게 되는 것
+ Task는 다시 foreground로 나설 수 있고 사용자는 해당 태스크의 마지막화면을 볼 수 있음(해당 앱의 아이콘을 클릭하거나 홈버튼을 길게 누르명 보이는 최근 태스크 목록에서 태스크를 선택하면됨)-이것이 안드로이드 멀티태스킹의 예시
+ 여러개의 태스크가 동시에 백그라운드에 있을 수 있지만 메모리가 부족할 경우 시스템이 메모리를 회복하기 위해 백그라운드에 있는 태스크의 액티비티를 종료할 수 있음
+ 백스택의 액티비티들은 절대 재배치되지 않고 앱의특정 액티비티가 여러개의 액티비티로부터 실행될 수 있다면 그 때마다 새로운 객체로 스택에 추가될 것(스택에 있는 동일한 액티비티의 객체를 기본적으로는 재생성하지 않음)

## Managing Tasks
+ 태스크와 백스택을 위와 같은 방식으로 동작 시키면 잘 동작하지만 내 앱에서는 기본 동작과는 다르게 구현하고 싶을 때 매니페스트 파일의 \<activity\> 요소에 관련 속성을 추가하거나, 소스코드의 startActivity()에 넘길 인텐트에 플래그를 추가함으로써 구현할 수 있음
+ 인텐트에 포함된 플래그들이 매니페스트 파일에 지정된 시작모드보다 우선임

+ \<activity\> 요소의 주요 속성들
  - taskAffinity
  - launchMode
  - allowTaskReparenting
  - clearTaskOnLaunch
  - alwaysRetainTaskState
  - finishOnTaskLaunch
  
+ Intent flags 속성
  - FLAG_ACTIVITY_NEW_TASK
  - FLAG_ACTIVITY_CLEAR_TOP
  - FLAG_ACTIVITY_SINGLE_TOP

+ launch mode정의 두가지 방식
  - 매니페스트 파일 사용
    * 매니페스트 파일에 액티비티를 선언할 때 액티비티 생성시 태스크에 어떻게 속하게 될지를 지정할 수 있음
  - 인텐트 플래그 사용
    * 소스코드에서 startActivity()를 호출할 때 인텐트 플래그를 추가해서 액티비티가 태스크에 어떻게 속하게 될지 지정할 수 있음

## 4가지 launchMode
+ standard(기본값)
  - 시스템은 액티비티를 실행하려고 인텐트를 념겨주고 있는 해당 태스크에서 새로운 객체를 생성
  - 여러번 객체를 생성할 수 있고, 각각 서로 다른 태스크에 들어갈 수 있고 하나의 태스크가 여러개의 객체를 포함할 수 있음
+ singleTop
  - 어떤 액티비티의 객체가 이미 현재 태스크의 top에 있는데 그 액티비티를 startActivity()를 호출하게 되면 시스템은 액티비티의 새 객체를 생성하는 대신 태스크의 top에 있는 액티비티 객체의 onNewIntent()를 호출함으로써 재사용함
  - standard와 마찬가지로 액티비티는 여러번 객체를 생성할 수 있고 각각은 서로 다른 태스크에 들어갈 수 있으며 하나의 태스크가 여러개의 객체를 포함할 수 있지만 태스크의 top에 하나의 액티비티에 대한 2개의 객체가 들어가는 상황만은 허용하지 않으며 이미 있는 객체를 재사용하도록 하는 것
  - top에 있는 것만 재사용이 가능하며 top이 아닌 activity는 재사용이 아닌 새로운 객체가 생성되어 백스택에 추가 됨
+ singleTask
  - 시스템은 새 태스크를 생성하고 태스크의 root에 액티비티의 새 객체를 생성하지만 태스크에 이미 해당 액티비티의 객체가 존재한다면 액티비티의 새 객체를 생성하지 않고 기존 객체의 onNewIntent()를 호출함으로써 재사용. 하나의 액티비티에대한 객체는 오직 하나만 존재할 수 있음
+ singleInstance
  - 자신이 속한 태스크에 다른 액티비티의 객체들을 들어오지 못하게 함.
  - 이 액티비티에서 다른 액티비티를 실행하면 그 액티비티는 다른 태스크에 속하게 됨

## Intent flags
+ FLAG_ACTIVITY_NEW_TASK
  - 실행하려는 액티비티의 객체가 존재하지 않으면 새 태스크의 root에 액티비티의 새 객체가 들어가고, background에 액티비티를 담고 있는 태스크가 있다면 foreground로 가져와 마지막 상태를 복구하고 인텐트를 onNewIntent()에 넘겨줌
  - backgroud에 있던 태스크의 top에 있던 액티비티가 실행되기 때문에 실행하고자 했던 액티비티와 실행된 액티비티의 결과가 다를 수 있으므로 대부분의 경우 FLAG_ACTIVITY_CLEAR_TOP과 함께 사용(이 두개를 합치면 singleTask의 역할과 같다고 함)
+ FLAG_ACTIVITY_SINGLE_TOP
  - 현재 실행중인 액티비티(현재 태스크의 TOP)에서 다시 동일한 액티비티를 실행하려는 경우 새 객체의 생성 대신 현재 액티비티의 onNewIntent()를 호출하여 재사용(singleTop의 역할과 같음)
+ FLAG_ACTIVITYT_CLEAR_TOP
  - 실행하려는 액티비티의 객체가 이미 현재 테스크에 존재하면 새 객체의 생성 대신 그 액티비티 객체의 위에 있는 다른 액티비티들을 모두 제거해 top이 되도록 함(그렇기 때문에 FLAG_ACTIVITY_NEW_TASK와 함께 사용).   
             

