# 프로세스 생명주기  
## 애플리케이션 프로세스  
+ 대부분 모든 Android 애플리케이션은 자체 Linux 프로세스에서 실행되고, 시스템이 메모리를 회수해야 할 때까지 계속 실행 됨  
+ Android 프로세스의 수명 주기는 애플리케이션에서 관리되는 것이 아니라, 애플리케이션이 가진 요소들의 중요성과 시스템이 사용할 수 있는 잔여 메모리 양을 조합한 시스템에 의해 결정 됨  
+ 따라서, 안드로이드 개발자는 다양한 애플리케이션 컴포넌트(Activity, Service, Broadcast Receiver)가 앱의 프로세스의 중요도에 영향을 미치는 방식을 이해해야 함  
+ 컴포넌트들을 올바르게 사용하지 않는다면 애플리케이션 프로세스가 종료될 수 있음  

## 중요도 계층구조  
+ 메모리가 부족할 때 종료해야하는 프로세스를 결정하기 위해 중요도에 따라 프로세스들을 유형별로 계층 구조에 배치함  
+ 1.포그라운드 프로세스  
  - 사용자가 현재 하고 있는 작업에 필수로 필요한 프로세스  
  - 다양한 컴포넌트들로 인해 포그라운드로 간주되고, 아래 중 하나라도 해당되면 포그라운드 프로세스로 간주 됨  
    * 프로세스가 사용자와 상호작용하고 있는 Activity를 실행중인 경우  
    * 프로세스에 현재 실행중인 BroadcastReceiver가 있는 경우  
    * 프로세스에 콜백 메서드(onCreate,onStart,onDestroy)중에서 현재 코드를 실행 중인 Service가 있는 경우  
  - 포그라운드 프로세스는 메모리가 매우 부족하여 포그라운드 프로세스조차도 계속 실행할 수 없을 경우에만 종료함  

+ 2.가시적 프로세스  
  - 사용자가 현재 알고 있는 작업을 수행중인 프로세스로, 종료되면 사용자에게 부정적인 영향을 미치고 다음 조건에 해당되는 프로세스를 가시적 프로세스로 간주  
    + 프로세스가 화면상으로만 표시되고 포그라운드에 있지 않은 Activity(onPause호출)를 실행중인 경우(ex.대화 상자 뒤로 액티비티가 흐릿하게 보이는 경우)  
    + 프로세스에 startForeground()를 통해 포그라운드 서비스로 실행중인 Service가 있는 경우  
    + 프로세스에 사용자가 알고 있는 특정 기능에서 사용하는 서비스가 있는 경우  
  - 가시적 프로세스는 포그라운드 프로세스보다는 덜 제한적이지만 매우 중요한 것으로 간주되며 포그라운드 프로세스의 실행 상태를 유지하는데 필요한 상황이 아니면 종료되지 않음  

+ 3.서비스 프로세스  
  - startService()메서드로 시작된 Service를 유지하는 프로세스  
  - 이런 프로세스는 사용자에게 직접 표시되지는 않지만 사용자가 포커스를 갖고있는 작업(백그라운드 작업)을 실행  
  - 포그라운드 프로세스 및 가시적 프로세스를 유지할 메모리가 부족하지 않으면 항상 실행 유지  
  - 오랫동안 실행중인 서비스는 중요도가 강등되고, 캐시된 프로세스 목록으로 이전될 수 있음. 이로 인해 쓸데 없는 메모리 누수나 장기 실행 서비스가 메모리를 낭비하는 상황을 방지  

+ 4.캐시된 프로세스  
  - 당장 필요로하지 않는 프로세스로 다른곳에 메모리가 필요하다면 언제든지 종료할 수 있는 프로세스  
  - 캐시된 프로세스는 메모리 관리와 관련된 유일한 프로세스로 필요에 따라서 가장 오래된 프로세스를 정기적으로 종료시킴  
  - 캐시된 프로세스는 현재 사용자에게 표시되지 않는 하나 이상의 액티비티 인스턴스를 포함  
  - onStop이 호출된 프로세스(캐시된 프로세스)가 올바른 액티비티 수명 주기를 가진다면 시스템이 프로세스를 종료시키더라도 사용자에게 영향을 주지 않고, 연결된 액티비티가 새 프로세스에서 다시 생성되더라도 시스템이 이전의 UI를 복원할 수 있음  
  - 캐시된 프로세스들은 LRU스케줄링방식으로 유지되고 메모리 회수 시 가장 오랫동안 사용되지 않는 프로세스가 먼저 종료됨  

    
