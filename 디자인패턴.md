# 디자인 패턴
프로그래밍할 때 다양한 문제 상황에 대해 재사용 가능한 해결책
일반적인 문제를 해결하기 위해 최선의 방법을 공식화하거나 정의 하는 것  

Creational, Structural, Behavioral으로 구분 함

## Createational patterns
클래스의 인스턴스를 만드는 것과 관련 됨

Class creation patterns: 상속을 효과적으로 사용하는데 집중

Object creation patterns: 인스턴스를 효과적으로 생성하는데 집중

Singleton패턴이 대표적(Singleton은 하나의 클래스에 단 하나의 인스턴스를 허용하는 패턴)  
+ 하나의 클래스에 대해 앱이 시작될 때 최초 한번 메모리를 할당하고 단 하나의 인스턴스를 생성함
+ 장점은 고정된 메모리의 영역을 얻어 하나의 인스턴스만 생성해서 메모리 낭비가 방지 되고 인스턴스가 전역적으로 사용될 수 있어서 다른 클래스에서 데이터를 공유하고 변경할 수 있음
+ 단점은 멀티스레드환경에서 데이터 동기화 문제가 발생할 수 있고 싱글톤 인스턴스에게 많은 일을 위임하거나 데이터를 공유시킬 경우에 인스턴스간 결합도가 높아지게 되어 개방폐쇄원칙에 위배되게 됨


## Structural patterns  
클래스나 인스턴스들의 관계와 관련있음  

프로그램의 기능들 간에 인터페이스를 명확히 함

클래스나 인스턴스의 관계를 조정하고 구조를 짜맞추는 패턴들이 포함 됨

Adapter패턴이 대표적(외부와 접촉하는 인터페이스가 불일치해 상호 접근이 불가능한 객체들 사이의 연결점이 되어 두 객체를 연결해 주는 역할을 함)
+ 대표적으로 Recyclerview에서 adapter를 사용하며 Adapter는 리사이클러뷰에 푸시될 아이템뷰를 생성하는 역할을 함
+ 레이아웃매니저는 어떤 형태로 아이템뷰를 배치할 것인지를 결정 함
+ 뷰홀더는 화면에 표시될 아이템뷰를 저장하는 객체
+ 리사이클러뷰에 더해질 아이템뷰를 뷰홀더에서 저장하는데 둘 사이에 연관이 없어 접근이 불가능하기 때문에 어댑태 패턴을 활용해 두 객체를 연결


## Behavioral patterns
클래스와 인스턴스가 동작하는 방식이느 소통하는 방식관 관련 있음  

객체 속 작업이 진행되는 작업흐름을 정의하고 따라감  

알고리즘이나 기능들이 어떻게 흐르는지 어떤 순서로 소통하는 지에 대해 정의

Template Method가 대표적인 방법  
+ 어떤 동작의 알고리즘을 단위 기능 모듈로 분류하고 동작 순서를 정의  
+ 한꺼번에 구체적인 클래스를 구현하지 않고 추상클래스의 템플릿 메소드를 구현해 구체적인 클래스가 이를 상속받아 자신이 필요한 메소드를 작성해주는 방식


# MVC패턴
Model,View,Controller의 약자  
+ Model: 데이터를 가짐
+ View: 사용자에게 보여질 화면을 표현
+ Control: 사용자로부터 입력을 받고 이를 모델에 의해 View를 정의
 
비즈니스 처리 로직부분과 UI요소 부분을 분리시켜 서로 영향이 없도록 개발  

웹에서 주로 사용되는 패턴이고 안드로이드에서는 조금 다른 형태로 표현된다고 함  

MVC구조에서 입력은 모두 Control에서 발생하게 되고 이벤트가 발생한 Control에 의해 모듈의 정의와 View의 용도가 결정 됨  

안드로이드에서 Activity와 Fragment와 같은 것들이 View와 Control을 모두 가지고 있음  
+ setContentView(R.layout.activity_main)->View관련 메소드 
+ setOnClickListener->Control 관련된 메소드

안드로이드에서는 Class하나로 MVC가 처리 가능한 구조로 만들어지기 때문에 메소드와 클래스를 적절히 분리해서 복잡도를 관리해야 코드 파악에 어려움을 해결할 수 있음  
+ 장점으로는 Activity에서 모든 동작을 처리해줌으로써 개발기간이 감소할 수 있고 한 곳에 모여있기 때문에 코드 분석과 같은 가독성에 유리할 수 있음  
+ 단점으로 하나의 클래스에 코드양이 많아질 수 있고 View와 Model의 결합도가 상승하며 테스트코드 작성의 어려움이 있음

안드로이드에서 MVC패턴을 보면 Model은 분리되어 있고 View와 Control이 함께 있는 구조를 띔  


# MVP패턴
-----------아직 이해가 잘 안가는 구조---------  
Model,View,Presenter의 약자  
+ Model: Data와 관련된 처리 
    - MVC와 동일
+ View: 이벤트가 발생하면 Presenter로 알림
    - 액티비티 혹은 프래그먼트가 View의 역할만 담당하게 되어 View에 관련된 내용만을 표시
    - View 인터페이스를 구현해 해당 View를 담당할 Presenter에서 컨트롤하게 되는 것 
+ Presenter: View에서 전달받은 이벤트를 처리하여 다시 View로 반환
    - 본질적으로는 MVC의 컨트롤러와 같지만 뷰에 연결되는 것이 아닌 단순히 인터페이스라는 점이 다름
    - MVP를 구현하는 방법은 극닥적으로는 Presenter가 절대로 안드로이드 API나 코드가 참조되지 않도록 하는 것 
 
안드로이드에서 MVC패턴 중 View와 Control이 함께 공존하는 문제점 해결(MVP는 View와 Control이 묶이지 않도록 함)  

안드로이드에서 가장 많이 사용하는 패턴  


# MVVM패턴
Model, View, ViewModel의 약자  
+ Model: 디자인 패턴에서는 데이터와 데이터에 관련된 행위를 모두 합쳐 Model이라고 부르고 데이터와 데이터를 가져오는 로직자체를 Model이라고 생각할 수 있음
+ View: 사용자에게 화면으로 보여지는 모든 구조, 레이아웃을 View라고 부르고 View는 modle을 시각적으로 표현하고 사용자의 상호작용을 받고 data binding을 통해 입력을 View model에게 전달
+ ViewModel: ViewModel은 View의 추상화된 형태로 View에 보여져야하는 데이터와 명령들을 가지고 있음. ViewModel이 MVC패턴의 Controller나 MVP패턴의 Presenter와 다른점은 View가 ViewModel을 관찰하는 형태로 binding 되어있기 때문에 data의 갱신을 View가 자동으로 받을 수 있음

각각의 컴포넌트는 서로 reference를 갖지 않고 View->ViewModel->Model 형태의 단방향 dependency를 가짐  

소프트웨어를 최대한 기능적으로 작은 단위로 나누고 그에 따라 테스트가 쉬워지며 큰 프로젝트도 상대적으로 관리하기 좋아짐  

ViewModel은 View와 Model 사이의 매개체 역할을 함  
+ Model에서 가져온 데이터를 UI에 필요한 정보로 가공
+ View가 가져갈 수 있도록 해당 데이터의 변경에 대한 notify를 보냄
+ View는 ViewModel의 레퍼런스를 가지지만 ViewModel은 View에 대한 정보가 전혀 없어야 하고 만약 ViewModel이 View의 레퍼런스를 가진다면 lifecycle에 메모리 누수가 발생할 수 있음








