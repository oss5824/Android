# 코틀린 사용을 위한 기본 문법  
## 1.코딩 준비하기  
+ 코딩 준비하기의 핵심 키워드는 로그와 로그캣  
  - 엄청나게 많은 로그 중 원하는 내용을 찾기란 쉽지 않기 때문에 중간중간 적정하게 사용할줄 알아야 함  
## 2.배열과 컬렉션  
+ 배열  
  - 먼저 개수를 정해 놓고 사용해야 하며 중간에 개수를 추가하거나 제거할 수 없음  
  - 배열 격체는 Int, Long, Char등과 같은 기본 타입 뒤에 Array를 붙여서 만듦(ex.IntArray(10))  
  - 값으로 배열 공간 할당하는 법 (ex.arrayOf("MON","TUE","WED"))  
+ 컬렉션  
  - 여러 개의 값을 넣을 수 있는 자료형에는 배열 외에도 컬렉션이 있음  
  - 배열과 다르게 공간의 크기를 처음 크기로 고정하지 않고 임의의 개수를 담을 수 있음  
  - 컬렉션을 크게 List, Map, Set이 있음  
  - 접두어가 없는 컬렉션도 있지만 잘 사용하지 않기 때문에 보통 mutable이라는 접두어가 붙음  
  - 코틀린에서 컬렉션은 제네릭을 사용하지 않으면 생성할 수 없음(단, 값으로 초기화 할 때는 추론이 가능해서 생략 가능)  
    * 리스트  
      리스트는 저장되는 데이터에 인덱스를 부여한 컬렉션이며 중복된 값을 입력할 수 있음  
      코틀린에서 동적으로 리스트를 사용하기 위해서는 리스트 자료형 앞에 mutable이라는 접두어가 붙음  
      add함수를 사용해서 값을 추가할 수 있음
      인덱스를 따로 지정해주지 않아도 입력되는 순서대로 인덱스가 지정됨  
      set과 get을 통해 수정과 사용을 할 수 있음  
      removeAt을 통해 제거할 수 있음  
      개수를 가져오기 위해 size를 사용(set,get 등은 함수라고 하고 size는 프로퍼티라고 함. 괄호 사용의 유뮤)  
    * 셋  
      셋은 중복을 허용하지 않는 리스트  
      리스트와 유사한 구조이지만 인덱스로 조회할 수 없고 get함수도 지원하지 않음  
      remove를 통해 특정 값을 삭제 할 수 있음  
    * 맵  
      맵은 키와 값의 쌍으로 입력되는 컬렉션  
      맵의 키는 리스트의 인덱스와 비슷한데 맵에서는 키를 직접 입력해야 함  
      get함수에 키를 직접 입력해서 값을 꺼낼 수 있음  
      put함수를 통해 키는 유지한 채로 값을 수정할 수 있음  
      remove함수에 키를 입력해서 값을 삭제할 수 있음  
## 3.클래스와 설계  
+ 그룹화할 수 있는 함수와 변수를 한군데에 모아놓고 사용하기 쉽게 이름을 붙여놓은 것을 클래스라고 이해 하면 좋음  
+ {} 해당 중괄호를 스코프라고 부름  
+ 오브젝트를 사용하면 클래스를 생성자로 인스턴스화 하지 않아도 블록 안의 프로퍼티와 매서드를 호출해서 사용할 수 있음  
```kotlin  
object Pig{  
var name: String = "Pinky"  
  fun printName() {}  
  }  
```  
+ companion object는 일반 클래스에 object 기능을 추가하기 위해서 사용 함  
+ 위의 Pig코드를 companion object 블록으로 감싸주면 생성 과정 없이 오브젝트처럼 사용할 수 있음  
+ 생성자 파라미터가 있는 클래스의 상속  
  - 상속될 부모 클래스의 생성자에 파라미터가 있다면 자식 클래스의 생성자를 통해 값을 전달할 수 있음  
  - class 자식클래스(value: String): 부모클래스(value){}  
+ 코틀린은 클래스, 메서드, 프로퍼티에 대해 익스텐션을 지원  
+ 추상화와 인터페이스  
  - 추상화는 클래스를 개념 설계하기 위한 도구  
  - 외부 모듈에 제공하기 위해 메서드 이름을 나열한 명세서  
  - 누군가 설계해 놓은 개념 클래스 중에 실행 코드가 한 줄이라도 있으면 추상화  
  - 코드 없이 메서드 이름만 나열되어 있으면 인터페이스  
## 4.Null Safety  
+ 코틀린은 null값의 처리에 많은 공을 들인 언어  
+ null은 프로그래밍하면서 항상 이슈의 중심에 있는데 null로 인해 프로그램 전체 혹은 앱 전체가 멈출 수 있기 때문  
+ null값을 허용해주기 위해서 타입 뒤에 ?(물음표)를 입력해야 함  
+ 함수의 리턴타입에도 물음표를 붙여서 null허용 여부를 설정할 수 있음(Nullable)  
  - 사용목적: null을 입력받기 위해 사용 ex) var nullable: 타입?  
+ 더 안전한 호출(safe call)을 하기 위해서는 ?.(물음표와 온점)을 사용  
  - 사용목적: null일 때 ?.다음에 나오는 속성이나 명령어를 처리하지 않기 위해 사용 ex)var result=변수?.length  
+ Null값을 대체하기 위해서 Elvis Operator ?:(물음표와 콜론)을 사용  
  - 사용목적: null일 때 ?:다음에 나오는 값을 기본값으로 사용 ex) var result=변수?:0  
## 5.지연초기화  
+ 클래스 코드에 Nullable처리가 남용되는 것을 방지해 주기 위해 lateinit과 lazy를 사용  
+ lateinit의 특징  
  - var로 선언된 클래스의 프로퍼티에만 사용할 수 있음  
  - nulll은 허용되지 않음  
  - 기본 자료형 Int,Long,Double,Float등은 사용할 수 없음  
  - lateinit은 변수만 미리 선언해 놓는 방식이기 때문에 초기화 되지 않은 상황이 발생할 수 있다면 Nullabe로 초기화  
+ lazy  
  - lazy는 읽기 전용 변수인 val을 사용하는 지연 초기화  
  - lateinit이 입력된 값을 변경할 수 있는 반면, lazy는 입력 값을 변경할 수 없음  
  - lazy는 선언 시에 초기화를 하기 때문에 초기화 과정이 필요 없음  
  - lazy는 리소스가 너무 크면 전체 처리 속도에 나쁜 영향을 미칠 수 있기 때문에 복잡한 코드라면 미리 초기화하는게 좋음  
## 6.스코프 함수  
+ 스코프 함수는 코드를 축약해서 표현할 수 있도록 도와주는 함수  
+ run,let처럼 괄호 없이 일종의 키워드 같이 사용할 수 있으며 lateinit과 함께 Safe call의 남용을 막아줌  
+ run,let,apply,also,with 등이 있음  
+ run과 let은 자신의 함수 스코프 안에서 호출한 대상을 this와 it으로 대체해서 사용할 수 있음  
```kotlin  
list.run{  
val listSize=size//this를 생략한채로 내부에서 size 프로퍼티를 직접호출하는 방식  
}  
```  
+ let에서는 호출한 대상을 it으로 사용할 수 있고 it을 생략할 수는 없지만 target과 같은 다름이름으로 바꿀 수 있음  
```kotlin  
list.let{it->  
val list=it.size  
}  
```  
+ apply,also를 사용하면 스코프 함수 안에서 코드가 모두 완료된 후 자기 자신을 되돌려 줌  
+ let,run,with는 자기 자신이 아닌 스코프의 마지막 코드를 반환  
