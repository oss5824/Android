# 스레드와 코루틴  
## 1.스레드와 루퍼  
+ 안드로이드의 스레드는 크게 1개만 존재하는 메인 스레드와 여러 개가 존재할 수 있는 백그라운드 스레드로 나눌 수 있음  
+ 메인스레드(UI 스레드) 
  - 메인스레드는 화면의 UI를 그리는 처리를 담당, 안드로이드 UI툴킷의 구성요소와 상호작용하고 UI이벤트를 사용자에게 응답하는 스레드  
  - 안드로이드 시스템은 새로운 앱을 실행하면 새로운 리눅스 프로세스를 실행함  
  - 기본적으로 메인 액티비티를 비롯한 모든 컴포넌트는 단일 프로세스 및 메인 스레드에서 실행 됨  
  - 시간이 오래걸리는 코드는 새로운 스레드를 생성해서 처리해야 함  
  - 애플리케이션은 성능을 위해 멀티 스레드를 많이 활용하지만, UI를 업데이트 하는 데는 단일 스레드 모델이 적용 됨(멀티 스레드로 UI를 업데이트 하면 동일한 UI 자원을 사용할 때 교착상태(deadlock), 경합상태(race condition) 등 여러 문제가 발생할 수 있음)  
  - 메인 스레드는 핸들러 스레드라서 활성화된 루퍼를 가지고 있음  
+ 백그라운드 스레드  
  - 안드로이드 시스템은 메모리 이외의 다른 곳에서 데이터를 가져오는 작업을 백그라운드 스레드에서 처리하는 것을 권장(ex)네트워크 작업, 파일 업로드와 다운로드 등등)  
 
Thread클래스를 상속받아 스레드를 생성할 수 있음  
```kotlin  
class WorkerThread: Threae(){  
  override fun run(){  
  }//스레드가 처리할 로직을 정의하는 run()메서드를 오버라이드  
}  
```  
  Runnable 인터페이스를 구현해 스레드를 생성할 수 있음  
```kotlin  
class WorkerRunnable: Runnable{  
  override fun run(){  
  }  
}  
```
람다식으로 Runnable 익명객체 구현이 가능  
```kotlin  
Thread{  
}.start()  
```   
코틀린에서 제공하는 thread()  
```kotlin   
thread(start=true){  
}  
```  
+ 위와 같은 방식으로 코드를 분산함으로써 더 효율적인 앱을 만들 수 있지만 백그라운드 스레드는 UI구성요소에 접근하면 안된다는 중요한 규칙이 있음(메인 스레드 이외의 스레드는 UI를 업데이트 할 수 없음)  
+ 핸들러와 루퍼  
  - 안드로이드는 메인 스레드와 백그라운드 스레드 및 스레드 간의 통신을 위해 핸들러와 루퍼를 제공  
  - 루퍼  
    * 루퍼는 메인엑티비티가 실행됨과 동시에 for문 하나가 무한루프를 돌고 있는 서브 스레드  
    * 무한루프가 대기하고 있다가 자신의 큐에 쌓인 메시지를 핸들러에 전달  
    * 여러 개의 백그라운드에서 큐에 메시지를 입력하면 입력된 순서대로 하나씩 꺼내서 핸들러에 전달  
  - 핸들러  
    * 핸들러는 루퍼가 있는 메인 스레드에서 주로 사용되며 새로 생성된 스레드들과 메인스레드와의 통신을 담당  
    * 핸들러는 루퍼를 통해 전달되는 메시지를 받아서 처리하는 일종의 명령어 처리기로 사용 됨  
    * 루퍼는 앱이 실행되면 자동으로 하나 생성되어 무한루프를 돌지만 핸들러는 개발자가 직접 생성해서 사용해야 함  
  - 메시지  
    * 메시지는 루퍼의 큐에 값을 전달하기 위해서 사용되는 클래스로 메시지 객체에 미리 정의해둔 코드를 입력하고 큐에 담아두면 루퍼가 꺼내서 핸들러에 전달  
## 2.코루틴  
+ 안드로이드는 스레드를 경량화한 코루틴이라는 새로운 도구를 제공  
+ 코루틴의 코(Co)는 함께 또는 동시에라는 의미  
+ 코루틴에서 스레드는 단지 코루틴이 실행되는 공간을 제공하는 역할을 하고 실행 중인 스레드를 중단시키지 않기 때문에 하나의 스레드에 여러개의 코루틴이 존재할 수 있음  
+ 컨텍스트 스위칭은 연산처리 시 프로세스를 교체하는 것을 말하는데, 컨텍스트 스위칭이 빈번하면 성능 저하가 발생하는데 코루틴의 컨텍스트 스위칭은 이런 프로세스 교체 개념을 소프트웨어적으로 진화시켜 성능 저하가 발생하지 않도록 설계 됨  
+ 코루틴 스코프  
  - 코루틴은 정해진 스코프 안에서 실행 됨  
  - 코루틴을 실행하는 스코프에는 글로벌 스코프와 코루틴 스코프가 있음  
    * 글로벌 스코프: 앱의 생명 주기와 함께 동작하기 때문에 앱이 실행되는 동안은 별도의 생명 주기 관리가 필요하지 않고 장시간 실행되어야 하는 코루틴이 있다면 GlobalScope를 사용하면 됨  
    * 코루틴 스코프: 버튼을 클릭해 서버의 정보를 가져오거나 파일을 여는 용도라면 필요할 때만 열고 완료되면 닫는 CoroutineScope를 사용해야 함   
  - 코루틴을 스레드와 비교했을 때 차이점은 코루틴을 가장 잘 설명하는 suspend 키워드이고, suspend키워드로 선언 된 함수가 호출되면 이전까지의 코드 실행이 멈추고, suspend함수의 처리가 완료된 후에 멈춰 있던 원래 스코프의 다음코드가 실행 됨  

+ GlobalScope  
```kotlin
GlobalScope.launch{    
}  
```  
+ CoroutineScope  
```kotlin  
CoroutineScope(Dispatchers.IO).launch{  
}  
```  
+ CoroutineScope에서 사용된 디스패처는 코루틴이 실행될 스레드를 정해주고 IO,Main,Default,Unconfined 등이 있지만 우선 IO와 Main을 잘 조합해서 사용하면 된다고 함  
  - IO: 이미지 다운로드,파일 입출력 등의 입출력에 최적화되어 있는 디스패처  
  - Main: 안드로이드의 기본 스레드에서 코루틴을 실행하고 UI와 상호작용에 최적화 되어있는 디스패처    

## ANR  
+ Android 앱의 UI 스레드가 너무 오랫동안 차단되면 ANR(애플리케이션 응답없음)이 나타나게 되고, 앱이 포그라운드에 있으면 사용자에게 다이얼로그를 표시함  
+ 메인스레드를 다른 곳에서 이미 점유한 상태라면 키 이벤트를 전달하지 못하고, 그 시간이 타임아웃을 넘는다면 ANR이 발생  
+ 키 이벤트인 볼륨, 메뉴, 백 키의 경우 눌리고서 5초 이상 지연 시 바로 ANR이 발생(홈 키와 전원 키는 앱과 별개로 작동하고 ANR 발생과는 무관)  
+ 터치 이벤트의 경우 키 이벤트의 경우와는 다르게 메인 스레드가 사용중이라면 대기하는 것은 동일하지만 타임아웃 된다고 해서 바로 ANR이 발생하지 않음  
+ 뒤이어 너치 이벤트가 왔을 때 두 번째 터치 이벤트가 전달되지 않는 시간이 타임아웃이 되면 ANR이 발생(메시지를 처리하는 도중에 화면을 두 번 이상 터치하게 되면 ANR이 발생)  
