# 화면 구성하기  
## 1.액티비티  
+ 액티비티는 사용자가 직접 보고 입력하는 화면을 담당하는 컴포넌트  
+ 메이저 컴포넌트 중 하나인 액티비티를 다루기 위해서는 먼저 컴포넌트를 구성하고 있는 핵심요소인 컨텍스트를 알아야 함  
### 컨텍스트  
  - 액티비티, 서비스 등의 컴포넌트와 스피너, 리사이클러뷰와 같은 화면 요소를 사용하기 위해서는 컨텍스트가 필요  
  - 컨텍스트는 시스템을 사용하기 위한 프로퍼티와 메서드가 담겨있는 클래스  
  - 대부분의 컨텍스트는 컴포넌트 실행시 함께 생성되고 생성된 컴포넌트가 가지고 있는 메서드를 호출해 도구들 사용 가능  
  - 안드로이드에서의 컨텍스트는 앱을 실행하기 위해 잘 짜여진 설계도의 개념으로 앱에서 사용하는 기본 기능이 담긴 기본 클래스  
  - 컨텍스트의 종류  
    * 애플리케이션 컨텍스트  
      애플리케이션 컨텍스트는 애플리케이션과 관련된 핵슴 기능을 담고 있는 클래스  
      앱을 통틀어서 하나의 인스턴스만 생성됨  
      액티비티나 서비스 같은 컴포넌트에서 직접 호출해서 사용할 수 있는데 호출하는 지점과 관계없이 모두 둥일한 컨텍스트를 호출  
    * 베이스 컨텍스트  
      베이스 컨텍스트는 안드로이드의 4대 메이저 컴포넌트인 액티비티,서비스,컨텐트 프로바이더,브로드캐스트 리시버의 기반 클래스  
      각각의 컴포넌트에서 baseContext 또는 this로 컨텍스트를 사용할 수 있고 호출되는 지점에 따라 서로 다른 컨텍스트가 호출  
  - 화면과 관련된 기능은 액티비티의 컨텍스트에서만 제공(화면에 그리는 것은 액티비티에서만 가능)  
### 인텐트  
+ MainActivity외에 다른 액티비티를 사용할 때는 인텐트에 새 액티비티의 이름을 담아서 시스템에 전달해야 함  
  - 생성한 인텐트를 startActivity()메서드에 담아서 호출하면 액티비티 매니저(Activity Manager)에 전달 됨  
  - 액티비티 매니저는 인텐트를 분석해 지정한 액티비티를 실행시킴  
  - 호출한 액티비티의 결과를 다시 돌려받기 위해서는 startActivityForResult()메서드를 사용해야만 함  
+ 액티비티와 같은 컴포넌트는 인텐트를 통해 데이터도 주고받을 수 있음  
+ 인텐트 내부에는 번들이라는 데이터 저장 공간이 있고 이 번들에 데이터를 담아서 주고 받을 수 있음  
+ 인텐트에 값을 입력할 때는 키와 값의 조합으로 번들에 직접 넣고, 꺼낼 때는 처음 입력했던 키로 꺼냄(Map처럼 동작함)  
+ 자신을 호출했던 액티비티로 값을 돌려줄 때는 대상을 지정하지 않아도 되므로 Intent안에는 아무것도 담지 않아도 됨  
+ Intent와 상태값을 setResult() 메서드에 담아서 실행하면 호출한 측으로 전달 됨  
  - 상태 값은 RESULT_OK와 RESULT_CANCELED로 안드로이드에 이미 상수로 정의되어 있음  
  - setResult(RESULT_OK,returnIntent)  
+ 호출한 쪽에서는 onActivityResult함수를 override해서 돌려받은 인텐트에서 꺼내서 사용  
### 액티비티 생명주기  
+ 앱에 상태 변화가 있을 때마다 화면에 보여지는 액티비티의 생명 주기 메서드를 호출하여 상태 변화를 알려줌  
+ 액티비티 생명주기 메서드  
  - onCreate() 액티비티가 생성됨  
  - onStart() 화면이 보이기 시작  
  - onResume() 실제 액티비티가 실행되고 있음  
  - onResume() 실행중은 생명주기 메서드가 따로 없음  
  - onPause() 액티비티 화면의 일부가 다른 액티비티에 가려짐  
  - onDestroy() 종료  
+ 액티비티 백스택  
  - 백스택은 액티비티 또는 화면 컴포넌트를 담는 안드로이드의 저장 공간  
  - 액티비티를 실행시키면 화면(백스텍)에 쌓이게 되고 사용자는 가장 위에 있는 액티비티를 보게 됨  
  - 뒤로가기 버튼을 누르거나 현재 액티비티를 종료하면 현재 액티비티가 스택에서 제거 되어 다음 액티비티가 화면에 올라옴  
+ 태스크와 프로세스  
  - 태스크는 애플리케이션에서 실행되는 프로세스를 관리하는 작업 단위  
  - 안드로이드는 애플리케이션의 실행 단위로 프로세스를 사용  
  - 안드로이드에서 태스크는 다른 프로세스의  액티비티를 함께 담을 수 있음  
  - 안드로이드는 서로 다른 애플리케이션의 액티비티를 공유할 수 있음(ex.카메라와 갤러리 액티비티)  
  - 액티비티 태스크는 두가지 방법으로 관리할 수 있음(매니페스트의 설정과 intent의 플래그 값으로 관리 가능)  

## 2.컨테이너: 목록 만들기  
+ 위젯의 위치를 다룰 때에 레이아웃을 사용했다면 위젯이나 다른 레이아웃에 데이터를 동적으로 표현해줄 때에는 컨테이너를 사용  
+ 컨테이너는 레이아웃과는 다르게 내부 요소의 위치를 결정할 수 있는 속성이 없기 때문에 다른 레이아웃을 컨테이너 안에 삽입해야 사용할 수 있음  
### 스피너  
+ 스피너는 여러 개의 목록 중에서 하나를 선택할 수 있는 선택도구  
+ 복수의 데이터를 처리할 수 있는 컨테이너 구조  
+ 스피너는 어댑터라는 연결도구를 사용해 화면에 나타낼 데이터와 화면에 보여주는 스피너를 연결함  
+ 여러개의 데이터가 어댑터에 입력되면 1개의 데이터당 1개의 아이템 레이아웃이 생성되어 화면에 목록 형태로 나타남  
### 리사이클러뷰  
+ 리사이클러뷰는 스피너가 조금 더 확장된 형태  
+ 리사이클러뷰도 스피너처럼 목록을 화면에 출력하는데 레이아웃 매니저를 이용하면 간단한 코드만으로 리스트를 그리드로 바꿀 수도 있음  
+ 리사이클러뷰는 리사이클러뷰어댑터라는 메서드 어댑터를 사용해서 데이터를 연결함(스피너보다는 훨씬 복잡한 구조이며 상속이 필요함)  
+ 리사이클러뷰어댑터는 개별 데이터에 대응하는 뷰홀더 클래스를 사용  
+ 상속하는 리사이클러뷰어댑터에 뷰홀더 클래스를 제네릭으로 지정해야하기 때문에 뷰홀더 클래스를 먼더 만들고 나서 어댑터 클래스를 생성해야 함  
+ 상속받는 Adapter클래스에 제네릭으로 뷰홀더를 지정해두면 Implements Methods로 코드를 자동완성할 때에 자동 완성된 메서드 중 하나가 파라미터 타입에 제네릭으로 지정해둔 뷰홀더를 사용함  
+ 뷰홀더는 현재 화면에 보여지는 개수만큼만 생성되고 목록이 위쪽으로 스크롤 될 경우 가장 위의 뷰홀더를 아래에서 재사용한 후 데이터만 바꿔주기 때문에 앱의 효율성이 향상 됨  
+ 어댑터 클래스의 기본 구성(어댑터에 설계되어 있는 3개의 인터페이스를 반드시 구현해야 함)  
```kotlin  
class 어댑터(): RecyclerView.Adapter<Holder>{  
    onCreateViewHolder()//한 화면에 그려지는 아이템 개수만큼 레이아웃 생성  
    getItemCount()//목록에 보여줄 아이템의 개수  
    onBindViewHolder()//생성된 아이템 레이아웃 값 입력 후 목록에 출력  
}  
```  
+ inflate(inflater,parent,attachToRoot)파라미터의 의미  
  -  inflater: 바인딩을 생성할 때 사용하는 인플레이터로 액티비티에서와는 다르게 LayoutInflater.from을 사용해서 생성해야 함  
  -  parent: 생성되는 바인딩이 속하는 부모 뷰(레이아웃)  
  -  attachToRoot: true일 경우 attach해야하는 대상으로 root를 지정하고 아래에 붙임. false일 경우 뷰의 최상위 레이아웃의 속석응로 기본으로 레이아웃이 적용 됨  
+ 리사이클러뷰에서 사용할 수 있는 레이아웃 매니저의 종류는 세 가지(LinearLayoutManager, GridLayoutManager, StaggeredGridLayoutManager)  
## 3.액티비티의 조각 프래그먼트 다루기  
+ 화면을 분할해서 독립적인 코드로 구성할 수 있게 도와주는 것이 프래그먼트  
+ 프래그먼트는 서로 다른 크기의 화면을 가진 기기에서 하나의 액티비티로 서로 다른 레이아웃을 구성할 수 있도록 설계 됨  
+ 프래그먼트는 단독으로 사용되지 않고 액티비티의 일부로 사용 됨  
+ 액티비티가 프래그먼트를 요청하면 onCreateView()메서드를 통해 뷰를 만들어서 보여줌  
+ onCreateView()메서드는 리사이클러뷰의 onCreateViewHolder()메서드처럼 동작함  
+ 액티비티에 프래그먼트를 삽입하기 위해서는 프래그먼트 매니저를 통해 삽입할 에이아웃의 아이디를 지정하고, 프래그먼트를 삽입하는 과정은 하나의 트랜잭션으로 관리되기 때문에 트랜잭션 매니저를 통해 begin transaction > add fragment > commit transaction의 순서로 처리 됨  
    - 트랜잭션은 여러 개의 의존성이 있는 동작을 한 번에 실행할 때 주안에 하나라도 잘못되면 모든 동작을 복구하는 하나의 작업 단위  
+ 프래그먼트에서 뒤로 가기 버튼을 사용하기 위해서는 transaction.addToBackStack("프래그먼트")를 추가해 줘야 함  
+ addToBackStack()을 사용하지 않은 채 뒤로가기를 하면 액티비티가 종료 됨  
+ 메인 Activity를 전달받을 때에는 프래그먼트의 생명 주기 메서드 중에 onAttach(Context)를 통해 코드를 전달받는 것이 가장 일반적  
+ 프래그먼트로 값을 전달하기 위해서는 Intent에 값을 담을 때와 동일한 구조로 Bundle을 생성해서 전달할 값을 담아 프래그먼트 매니저를 통해 삽입  
+ 프래그먼트의 생명 주기 관리  
+ 생명주기 메서드
    - onAttach()  
        * 프래그먼트 매니저를 통해 액티비티에 프래그먼트가 추가되고 commint되는 순간 호출 됨  
        * 생성자를 호출하는 순간에는 호출되지 않음  
        * onAttach()를 통해 넘어오는 Context에서만 상위 액티비티를 꺼낼 수 있음  
    - onCreate()  
        * 프래그먼트가 생성됨가 동시에 호출 됨  
        * 프래그먼트 자원을 초기화할 때 사용 됨  
    - onCreateView()  
        * 사용자 인터페이스와 관련된 뷰를 초기화하기 위해 사용  
    - onStart()  
        * 액티비티의 startActivity로 새로운 액티비티를 호출하는 것처럼 프래그먼트가 새로 add되거나 화면에서 사라졌다가 다시 나타나면 onCreateView()는 호출되지 않고 onStart()로만 호출 됨  
        * 주로 화면에 생성 후에 화면에 입력될 값을 초기화하는 용도로 사용 됨  
    - onResume()  
        * onStart()와 같은 용도로 사용 됨  
        * 다른점은 소멸 주기 메서드가 onPause()상태에서 멈췄을 때 onStart()를 거치지 않고 onResume()이 바로 호출됨  
+ 소멸 주기 메서드  
    - onPause()  
        * 현재 프래그먼트가 화면에서 사라지면 호출 됨  
    - onStop()  
        * onPause()와 다른 점은 현재 프래그먼트가 화면에 일부분이라도 보이면 onStop()은 호출되지 않음  
    - onDestroyView()  
        * 뷰의 초기화를 해제하는 용도로 사용 됨  
        * 이 메서드가 호출된 후 생성 주기 메서드인 onCreateView()에서 인플레이터로 생성한 View가 모두 소멸 됨  ]
    - onDestroy()  
        * 액티비티에는 아직 남아있지만 프래그먼트 자체는 소멸 됨  
        * 프래그먼트에 연결된 모든 자원을 해제하는 용도로 사용 됨  
    - onDetach()  
        * 액티비티에서 연결이 해제 됨  
## 4. 뷰 사용하기  
+ 뷰는 화면을 구성하는 최소 단위의 컴포넌트  
+ 계층 구조로 나타낸다면 앱 > 프래그먼트 > 뷰그룹 > 뷰  
+ 뷰 그룹은 레이아웃이라고 할 수 있고 뷰는 UI편집기의 팔레트에 있는 모든 것들을 뷰라고 할 수 있음  
+ 화면을 구성하기 위해 사용한 레이아웃과 위젯 등은 모두 최상위 클래스인 View클래스를 상속받아 구현  
+ 레이아웃 파일에서 UI편집기로 만들어진 태그 안의 속성들은 AttributeSet으로 만들어진 후에 해당 클래스의 생성자에 파라미터로 전달되고 안드로이드는 입력된 속성들을 분석해 화면에 그려줌  
+ 부모클래스인 View에 위젯이 전달되면 View는 받아서 글자,크기,색상,위치 등을 결정하고 onDraw()메서드를 사용해서 화면에 그려줌(onDraw()메서드의 파라미터로 넘어오는 Canvas는 일종의 그리기 도구)  
+ 회사에서 프로젝트를 진행하면 텍스트뷰와 같은 기본 위젯은 잘 사용하지 않고 보통 기본 위젯을 상속받아 앞에 접두어를 붙여 커스텀 위젯으로 사용(위젯의 커스터마이징은 3단계로 진행)  
    - attrs.xml파일 생성  
        * 새로운 위젯을 생성하고 사용할 때 위젯 이름 뿐만이 아니라 속성의 이름과 입력되는 값의 타입을 정의하고 사용할 수 있음  
        * 태그 속성의 prefix가 android가 아닌 custom을 사용해서 attrs.xml에 정의된 새로운 속성값을 사용할 수 있음  
    - 커스텀 위젯 클래스 생성  
        * 커스터마이징을 하기 위한 위젯 클래스를 상속받아 클래스를 생성하고 새롭게 정의한 속성을 처리하는 코드를 작성  
    - 레이아웃에 태그 적용  
        * 생성된 커스텀 클래스를 레이아웃 파일에 태그로 적용하고 커스텀 위젯은 컨스트레이아웃처럼 위젯 클래스의 패키지 경로명도 함께 입력해서 사용함  
## 5.탭 메뉴로 화면 구성하기  
+ 안드로이드나 아이폰에서 가장 많이 사용되는 메뉴의 형태는 탭이나 스와이프로 화면을 전환하는 형태(스와이프는 손가락으로 화면을 쓸어 넘기는 동작을 의미)  
+ 안드로이드에서는 스와이프로 화면을 전환할 수 있도록 컨테이너인 뷰페이저를 제공하고 탭 메뉴 구성을 위해서 탭 레이아웃을 제공  
+ 뷰페이저는 리사이클러뷰와 구현방식이 비슷한데 한 화면에 하나의 아이템만 보이는 리사이클러뷰라고 생각하면 되고 페이저 어댑터를 통해서 뷰페이저에서 보일 화면들을 연결하는 구조도 리사이클러뷰와 같음  
